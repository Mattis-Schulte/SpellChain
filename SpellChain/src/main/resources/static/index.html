<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <meta name="description" content="SpellChain is a demo Spring Boot application showcasing real-time WebSockets (STOMP) and a lightweight browser UI. It's a 2–4 player word game where players create/join rooms, add letters, complete dictionary-backed words, and see live updates.">
  <title>SpellChain — A Spring Boot Demo</title>
  <style>
    :root{--fg:#000;--bg:#fff;--muted:#333;--error:#b00000;--ok:#064;--bd:#000;--disabled:#999}
    .dark{--fg:#fff;--bg:#000;--muted:#bbb;--error:#ff8a8a;--ok:#8f8;--bd:#fff}

    html,body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 Consolas,monospace;height:auto;min-height:100vh;min-height:100dvh}
    body{display:flex;align-items:center;justify-content:center}

    .panel{
      --panel-h:min(560px, calc(100vh - 69px));
      --panel-h:min(560px, calc(100dvh - 69px));

      width:min(860px,calc(100vw - 24px));
      height:var(--panel-h);
      border:1px solid var(--bd);
      border-radius:4px;
      display:flex;
      flex-direction:column;

      transform:translateY(calc(-1 * min(8vh, max(0px, calc((100vh - var(--panel-h)) / 2 - 12px)))));
      transform:translateY(calc(-1 * min(8dvh, max(0px, calc((100dvh - var(--panel-h)) / 2 - 12px)))));

      margin:0 env(safe-area-inset-right) 0 env(safe-area-inset-left);
      box-sizing:border-box;
      overflow:hidden
    }

    .header{padding:8px 10px;border-bottom:1px solid var(--bd);display:flex;gap:10px;align-items:center}
    .dot{width:10px;height:10px;border-radius:50%;border:1px solid var(--bd);background:var(--bg);aspect-ratio:1/1}
    .dot.connected{background:var(--bd)}

    .stats{padding:6px 10px;border-bottom:1px dashed var(--bd);display:flex;gap:16px;align-items:center;flex-wrap:wrap}
    .badge,.input,.btn{background:var(--bg);border:1px solid var(--bd);color:var(--fg);border-radius:3px}
    .badge{padding:2px 6px;white-space:pre}
    .scores{display:flex;gap:8px;flex-wrap:wrap}

    .body{flex:1;overflow:auto;padding:10px 10px;display:flex;flex-direction:column;gap:8px;-webkit-overflow-scrolling:touch}
    .body:not(:has(#termInput.hidden)){padding-bottom:0}
    .def{border:1px solid var(--bd);border-radius:3px;padding:6px;overflow-wrap:break-word}
    .def a,.def a:visited,.def a:hover,.def a:active,.def a:focus{color:var(--muted);text-decoration:underline}
    .title{font-weight:bold;margin-bottom:4px}
    .line{white-space:pre-wrap;margin:0}
    .meta{color:var(--muted)}
    .error{color:var(--error)}
    .ok{color:var(--ok)}

    .term-input{display:flex;align-items:center;gap:8px;border-top:1px dashed var(--bd);padding:8px 6px;min-height:40px;background:var(--bg);position:sticky;bottom:0}
    .term-input .prompt{width:18px;text-align:right;color:var(--fg);opacity:.9;font-weight:bold}
    .term-input input{flex:1;background:transparent;border:none;outline:none;color:var(--fg);font:inherit;caret-color:var(--fg);padding:6px 8px;min-width:36px}
    input::placeholder{color:var(--disabled)}

    .footer{padding:8px 10px;border-top:1px solid var(--bd);display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:space-between;z-index:1}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .spacer{flex:1}
    .btn{padding:6px 10px}
    .btn[disabled]{color:var(--disabled);border-color:var(--disabled)}
    .input{padding:6px 8px}
    .hidden{display:none}
    #log{flex:1 1 auto}
    .github-link{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;padding:8px 12px;font-size:13px;color:var(--fg);z-index:1000;opacity:.92;white-space:nowrap}

    @media (max-width:720px){
      body{align-items:stretch;justify-content:stretch}
      .panel{
        width:100%;
        height:calc(100vh - 66px);
        height:calc(100dvh - 66px);margin:8px calc(env(safe-area-inset-right) + 8px) 8px calc(env(safe-area-inset-left) + 8px);transform:none
      }
      .header,.stats,.body,.footer{padding:12px}
      .dot{width:12px;height:12px}
      .btn,.input{padding:10px 12px}
      #lobbyControls,#roomControls{width:100%}
      #lobbyControls .input,#lobbyControls .btn,#roomControls .btn{flex:1 1 auto;min-width:0}
      #joinRoomId{width:auto}
      .term-input .prompt{width:16px}
      .badge{padding:4px 8px}
    }
  </style>
</head>
<body>
<div class="panel">
  <div class="header">
    <div class="dot" id="connDot" title="connection"></div>
    <div id="connStatus">disconnected</div>
    <div class="spacer"></div>
    <div id="roomInfo">room: —</div>
  </div>

  <div class="stats">
    <div>Seq: <span id="seqBadge" class="badge">—</span></div>
    <div>Round: <span id="roundBadge" class="badge">—</span></div>
    <div class="scores">Scores: <span id="scoresBar">—</span></div>
  </div>

  <div class="body">
    <div id="defCard" class="def hidden"></div>
    <div id="log">
      <div class="line title">Welcome to SpellChain!</div>
      <div class="line meta">Players take turns adding exactly one character to the shared sequence.</div>
      <div class="line meta">Completing a valid word awards points based on its length, and the word's definition is displayed.</div>
      <div class="line meta">Once a word has been used by any player, it cannot be reused in subsequent turns.</div><br>
      <div class="line meta">Create a room to start a new game, or join an existing room using its ROOMID.</div>
    </div>
    <div id="termInput" class="term-input hidden">
      <div class="prompt">&gt;</div>
      <input id="charInput" maxlength="1" inputmode="text" placeholder="enter a character" autocomplete="off">
    </div>
  </div>

  <div class="footer">
    <div class="row" id="lobbyControls">
      <button class="btn" id="btnCreate">Create</button>
      <input class="input" id="joinRoomId" placeholder="ROOMID" style="width:120px">
      <button class="btn" id="btnJoin">Join</button>
    </div>

    <div class="row hidden" id="roomControls">
      <button class="btn" id="btnPlay" disabled>Play</button>
      <button class="btn hidden" id="btnAdd" disabled>Send</button>
      <button class="btn" id="btnExit">Exit</button>
    </div>

    <div id="statusRight">waiting</div>
  </div>
</div>

<a class="github-link" href="https://github.com/Mattis-Schulte/SpellChain" target="_blank" rel="noopener noreferrer">View this project on GitHub</a>

<script type="module">
  import { Client } from './stomp.min.js';

  // Consts
  const MAX_LOG = 300;
  const HB = 10000;
  const LETTER_RE = /\p{L}/u;
  const PATH = {
    create: '/app/createRoom',
    join: '/app/joinRoom',
    start: '/app/start',
    exit: '/app/exit',
    add: '/app/addCharacter',
    topic: id => `/topic/rooms/${id}`,
    userQueue: '/user/queue/reply'
  };

  // DOM
  const $ = id => document.getElementById(id);
  const ui = {
    connDot: $('connDot'), connStatus: $('connStatus'), roomInfo: $('roomInfo'),
    seq: $('seqBadge'), round: $('roundBadge'), scores: $('scoresBar'),
    def: $('defCard'), log: $('log'), term: $('termInput'), char: $('charInput'),
    lobby: $('lobbyControls'), roomCtl: $('roomControls'),
    btnCreate: $('btnCreate'), btnJoin: $('btnJoin'), btnPlay: $('btnPlay'),
    btnExit: $('btnExit'), btnAdd: $('btnAdd'),
    joinId: $('joinRoomId'), status: $('statusRight')
  };

  // State
  const S = {
    minPlayers: 2, maxPlayers: 4, allowedPunc: null,
    client: null, sub: null, connected: false,
    roomId: null, myNum: null, host: 1,
    started: false, joined: 0, current: null, round: null, sequence: '',
    found: [], leaving: false, lastMyTurn: false,
    hadDisconnect: false, connErrShown: false, postReconnect: false
  };

  // Derived/state helpers
  const first = s => ([...(s || '')][0] || '');
  const online = () => !!(S.client && S.connected);
  const inRoom = () => !!S.roomId;
  const myTurn = () => S.started && inRoom() && online() && S.current === S.myNum;
  const allowedChar = ch => {
    const c = first(ch);
    return !!c && (LETTER_RE.test(c) || S.allowedPunc?.has(c));
  };

  // Escaping for innerHTML content (definitions)
  const esc = s => (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

  // Log
  const addLine = (t, cls = '') => {
    const d = document.createElement('div');
    d.className = `line ${cls}`;
    d.textContent = t;
    ui.log.appendChild(d);
    while (ui.log.children.length > MAX_LOG) ui.log.removeChild(ui.log.firstChild);
  };
  const ok = t => addLine(t, 'ok');
  const err = t => addLine(t, 'error');

  // UI setters
  const setConn = on => {
    S.connected = !!on;
    ui.connDot.classList.toggle('connected', on);
    ui.connStatus.textContent = on ? 'connected' : 'disconnected';
  };
  const setSeq = s => { S.sequence = s || ''; ui.seq.textContent = S.sequence || '—'; };
  const setScores = m => {
    if (!m) { ui.scores.textContent = '—'; return; }
    const sorted = Object.keys(m).sort((a,b)=>+a-+b);
    ui.scores.textContent = sorted.map(k => `#${k}:${m[k]}`).join(' | ');
  };
  const setRound = v => { ui.round.textContent = (typeof v === 'number' && v > 0) ? String(v) : '—'; };
  const clearBody = () => { ui.def.classList.add('hidden'); ui.def.innerHTML = ''; ui.log.innerHTML = ''; };
  const setAllowedPunc = s => { S.allowedPunc = s ? new Set([...s]) : null; };
  const disableAllControls = () => {
    ui.btnCreate.disabled = true; ui.btnJoin.disabled = true; ui.btnPlay.disabled = true;
    ui.btnExit.disabled = true; ui.btnAdd.disabled = true;
    ui.joinId.disabled = true; ui.char.disabled = true;
  };

  // Domain
  const showDef = (word, pts, def) => {
    ui.def.innerHTML = `
      <div class="title">Completed: ${esc(word)} (+${pts})</div>
      <div>${esc(def || '').replace(/\bhttps?:\/\/[^\s<>"')\]\[]+[^\s<>"').,!?;\]:\]]/gi, u => `<a href="${u}" target="_blank" rel="noopener noreferrer">${u}</a>`)}</div>
    `;
    ui.def.classList.remove('hidden');
    S.found.push({ player: null, word, points: pts });
  };

  const maybeDef = msg => {
    const m = msg.match(/^\*\*\* Player (\d+) completed "(.+?)"! \((\d+) Point/i);
    if (!m) return false;
    const i = msg.indexOf('Definition: ');
    const [player, word, pts] = [Number(m[1]), m[2], Number(m[3] || 0)];
    showDef(word, pts, i >= 0 ? msg.slice(i + 12).trim() : '');
    S.found[S.found.length - 1].player = player;
    return true;
  };

  const showResults = (scores, rounds, lastSeq) => {
    const es = scores ? Object.entries(scores).map(([p, s]) => ({ p:+p, s:+s })) : [];
    es.sort((a,b) => b.s - a.s || a.p - b.p);
    const top = es[0]?.s ?? 0;
    const winners = es.filter(e => e.s === top);

    addLine('Game Over', 'meta');
    if (es.length) {
      addLine('Final scores:', 'meta');
      es.forEach(e => addLine(` - Player #${e.p}: ${e.s}`, 'meta'));
      const w = winners.map(e => `#${e.p}${e.p === S.myNum ? ' (You)' : ''}`).join(', ');
      addLine(`Winner${winners.length > 1 ? 's' : ''}: ${w}`, 'meta');
    } else {
      addLine('No scores recorded.', 'meta');
    }

    if (S.found.length) {
      addLine('Words found:', 'meta');
      S.found.forEach(w => addLine(` - Player #${w.player}: ${w.word} (+${w.points})`, 'meta'));
    }
    if (typeof rounds === 'number') addLine('Rounds: ' + rounds, 'meta');
    if (lastSeq) addLine('Last sequence: "' + lastSeq + '"', 'meta');
  };

  // STOMP helpers
  const publish = (dest, body = {}) => {
    if (!online()) return err('not connected');
    S.client.publish({ destination: dest, body: JSON.stringify(body) });
  };
  const resubscribeRoom = id => {
    S.sub?.unsubscribe();
    if (!id || !online()) return;
    S.sub = S.client.subscribe(PATH.topic(id), m => {
      try { handleRoom(JSON.parse(m.body)); } catch { err('bad room update'); }
    });
  };

  const resetRoom = (clear = false) => {
    S.sub?.unsubscribe();
    Object.assign(S, {
      roomId: null, myNum: null, host: 1, started: false,
      joined: 0, current: null, round: null, sequence: '',
      found: [], leaving: false, lastMyTurn: false, postReconnect: false
    });
    setSeq(''); setScores(null); setRound(null);
    if (clear) clearBody();
    updateUI();
  };

  // Handlers
  const handleUser = p => {
    if (!p) return;
    if (p.type === 'room_created') {
      clearBody();
      S.roomId = (p.roomId || '').toUpperCase();
      S.myNum = p.playerNumber;
      S.started = !!p.started;
      S.joined = Math.max(1, S.myNum);
      S.host = 1;
      S.current = null;
      S.round = null;
      ok(`room ${S.roomId} — you are player #${S.myNum}`);
      setRound(S.round);
      updateUI();
      resubscribeRoom(S.roomId);
      ui.joinId.value = '';
    } else if (p.type === 'error') {
      err(p.message || 'error');
    }
  };

  const handleRoom = u => {
    if (!u) return;
    const wasStarted = S.started;

    if ('started' in u) S.started = !!u.started;
    if ('joinedCount' in u) S.joined = u.joinedCount;
    if ('currentPlayer' in u) S.current = u.currentPlayer;
    if ('hostPlayer' in u) S.host = u.hostPlayer;
    if ('roundCount' in u) S.round = u.roundCount;

    // Fresh start: clear display, reset found list
    if (!wasStarted && S.started) {
      clearBody();
      S.found = [];
      if (!('roundCount' in u)) S.round = 1;
    }

    // Replace entire log with server-provided messages batch
    if (Array.isArray(u.messages) && u.messages.length) {
      clearBody();
      u.messages.forEach(m => { if (!maybeDef(m)) addLine(m); });
    }

    // Game ended
    if (wasStarted && !S.started) {
      showResults(u.scores || {}, u.roundCount, u.sequence);
      resetRoom(false);
      return;
    }

    // Room closed before start
    if (!S.started && Array.isArray(u.messages) && u.messages.some(m => /room closed/i.test(m))) {
      resetRoom(false);
      return;
    }

    if (u.scores && S.started) {
      setScores(u.scores);
      S.joined = Object.keys(u.scores).length;
    }

    if (typeof u.sequence === 'string') setSeq(u.sequence);

    // Manage turn input focus
    const turnNow = myTurn();
    if (turnNow && !S.lastMyTurn) {
      ui.char.value = '';
      setTimeout(() => { ui.char.focus(); }, 0);
    }
    S.lastMyTurn = turnNow;

    setRound(S.started ? S.round : null);
    updateUI();
  };

  const updateUI = () => {
    const inR = inRoom();
    const turn = myTurn();
    const minP = (typeof S.minPlayers === 'number') ? S.minPlayers : 2;
    const maxP = (typeof S.maxPlayers === 'number') ? S.maxPlayers : 4;

    ui.roomInfo.textContent =
      `room: ${inR ? S.roomId : '—'} | ${S.myNum ? ('you #' + S.myNum) : '—'} | ` +
      `players: ${(typeof S.joined === 'number' ? S.joined : '?')}/${maxP} | ${S.started ? 'started' : 'not started'}`;

    ui.lobby.classList.toggle('hidden', inR);
    ui.roomCtl.classList.toggle('hidden', !inR);
    ui.btnPlay.classList.toggle('hidden', !inR || S.started);
    ui.term.classList.toggle('hidden', !inR || !S.started);
    ui.btnAdd.classList.toggle('hidden', !inR || !S.started);

    if (!S.connected) {
      disableAllControls();
      ui.status.textContent = 'attempting to connect…';
      document.documentElement.classList.toggle('dark', false);
      return;
    }

    if (S.postReconnect && inR) {
      ui.btnExit.disabled = false;
      ui.status.textContent = 'Reconnected. Press Exit to start a new game.';
      return;
    }

    // Controls
    ui.btnPlay.disabled = !(inR && online() && S.myNum === S.host && !S.started && S.joined >= minP && S.joined < maxP);
    ui.btnAdd.disabled = !turn;
    ui.char.disabled = !turn;
    ui.btnExit.disabled = S.leaving || !inR || !online();

    ui.btnCreate.disabled = !online() || inR;
    ui.btnJoin.disabled = !online() || inR;
    ui.joinId.disabled = !online() || inR;

    // Status
    if (!inR) {
      ui.status.textContent = 'not in a room';
    } else if (!S.started) {
      ui.status.textContent = (S.myNum === S.host)
        ? `waiting for players; Play at ${minP}–${maxP - 1}; auto-start at ${maxP}`
        : `waiting for host; auto-start at ${maxP}`;
    } else {
      ui.status.textContent = turn ? 'your turn' : 'waiting for other players';
    }

    // Theme
    document.documentElement.classList.toggle('dark', S.started && !turn);
  };

  // Actions
  const requireOnline = () => { if (!online()) { err('not connected'); return false; } return true; };
  const requireInRoom = () => { if (!inRoom()) { err('not in a room'); return false; } return true; };

  ui.btnCreate.onclick = () => { if (requireOnline()) publish(PATH.create); };
  ui.btnJoin.onclick = () => {
    if (!requireOnline()) return;
    const rid = (ui.joinId.value || '').trim().toUpperCase();
    if (!rid) return err('enter room code');
    publish(PATH.join, { roomId: rid });
  };
  ui.btnPlay.onclick = () => {
    if (!requireOnline() || !requireInRoom()) return;
    publish(PATH.start, { roomId: S.roomId });
  };
  ui.btnExit.onclick = () => {
    if (S.postReconnect) { S.connErrShown = false; resetRoom(true); return; }
    if (!requireOnline() || !requireInRoom()) return;
    S.leaving = true;
    publish(PATH.exit);
    ui.status.textContent = 'leaving…';
    updateUI();
    if (!S.started) resetRoom(true);
  };
  ui.btnAdd.onclick = () => {
    if (!requireOnline() || !requireInRoom()) return;
    const ch = first(ui.char.value || '');
    if (!allowedChar(ch)) {
      const extra = S.allowedPunc ? ` or one of "${[...S.allowedPunc].join('')}"` : '';
      return err(`invalid character: enter a single letter${extra}`);
    }
    publish(PATH.add, { roomId: S.roomId, ch: ch.toLowerCase() });
    ui.char.value = '';
    ui.char.focus();
  };

  ui.joinId.addEventListener('input', updateUI);
  ui.joinId.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); ui.btnJoin.click(); } });
  ui.char.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); ui.btnAdd.click(); } });

  // Connection events
  const handleDisconnected = () => {
    setConn(false);
    S.hadDisconnect = true;
    if (inRoom() && !S.connErrShown) {
      err('Connection lost. You cannot continue this game. After reconnection, press Exit to start a new game.');
      S.connErrShown = true;
    }
    updateUI();
  };

  // Connect + config
  const connect = () => {
    const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
    S.client = new Client({
      brokerURL: `${wsScheme}://${location.host}/ws`,
      heartbeatIncoming: HB, heartbeatOutgoing: HB, debug: () => {},
      reconnectDelay: 3000
    });

    S.client.onConnect = () => {
      setConn(true);
      if (S.hadDisconnect) {
        if (inRoom()) S.postReconnect = true;
        S.hadDisconnect = false;
      }
      S.client.subscribe(PATH.userQueue, m => {
        try { handleUser(JSON.parse(m.body)); } catch { err('bad user reply'); }
      });
      updateUI();
    };

    S.client.onWebSocketError = handleDisconnected;
    S.client.onWebSocketClose = handleDisconnected;
    S.client.onStompError = f => err(f?.headers?.message || 'broker error');

    S.client.activate();
  };

  const boot = async () => {
    try {
      const r = await fetch('/config');
      if (!r.ok) throw 0;
      const c = await r.json();
      if (typeof c.minPlayers === 'number') S.minPlayers = c.minPlayers;
      if (typeof c.maxPlayers === 'number') S.maxPlayers = c.maxPlayers;
      setAllowedPunc(typeof c.allowedPunctuation === 'string' ? c.allowedPunctuation : null);
    } catch {
      S.minPlayers = 2; S.maxPlayers = 4; setAllowedPunc(null);
      err('Unable to load server config, using defaults 2–4; punctuation disabled until server provides it');
    } finally {
      connect();
    }
  };

  window.addEventListener('load', boot);
  window.addEventListener('beforeunload', () => {
    try {
      if (S.client && S.connected && !S.postReconnect) {
        S.client.publish({ destination: PATH.exit, body: '{}' });
      }
    } catch {}
    try { S.client?.deactivate(); } catch {}
  });
</script>
</body>
</html>